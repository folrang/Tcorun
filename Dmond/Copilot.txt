**프롬프트 [​수정할게 있어. 그사이 Visual studio 2026 으로 변경했고 .net 10... | Copilot Chat에서 사용해 보기](https://m365.cloud.microsoft/chat/entity1-d870f6cd-4aa5-4d42-9626-ab690c041429/eyJpZCI6IlZYTmxjbFl4ZkdoMGRIQnpPaTh2YzNWaWMzUnlZWFJsTFdsdWRDNXZabVpwWTJVdVkyOXRMM3hQU1VRNllUUXlPREptT0RRdE1qUm1PUzAwWTJKbUxUazJNRFl0WTJKbVptSmlZbVl5TlRGaGZHVXlNVE5tWm1Vd0xUQXdZekF0TkRreFppMDVNVE5sTFRkbU1UUXdabUprTmpabE0zd3lNREkyTFRBeExURTBWREE0T2pBME9qVXlMakUzTVRJek16aGEiLCJzY2VuYXJpbyI6InNoYXJlTGlua1ZpYVJpY2hDb3B5IiwicHJvcGVydGllcyI6eyJwcm9tcHRTb3VyY2UiOiJ1c2VyIiwiY2xpY2tUaW1lc3RhbXAiOiIyMDI2LTAxLTE0VDA4OjA0OjUyLjIwMloifSwiY2hhdFR5cGUiOiJ3ZWIiLCJ2ZXJzaW9uIjoxLjF9)**
​수정할게 있어. 그사이 Visual studio 2026 으로 변경했고 .net 10 을 사용할거야.
그리고 이제 위 내용을 모두 정리해서 최종본을 한번 더 자세히 알려줘.

**응답**
아래는 **Visual Studio 2026 + .NET 10** 환경에서 바로 빌드·실행 가능한 **최종본**입니다.  
**단일 프로세스**에서 **HTTP/1.1·HTTP/2·HTTP/3(QUIC)**, **gRPC(HTTPS/HTTP/2)**, **고성능 TCP(SocketAsyncEventArgs, 길이‑프레임, 무압축·무암호화)** 를 동시에 호스팅하고, **로컬 MSSQL + Redis** 를 사용합니다.  
테스트 인증서는 `dotnet dev-certs https --trust` 로 준비합니다. (Windows 11에서 바로 신뢰 처리됨) [1](https://stackoverflow.com/questions/73736969/net-6-kestrel-http3-and-quic-linux-exception-this-platform-doesnt-support-quic)[2](https://learn.microsoft.com/en-us/dotnet/standard/security/cross-platform-cryptography)

---

# 1) 솔루션 구조

```
Solution/
 ├─ Common/                      # 서버/클라이언트 공용: 길이-프레임 코덱
 │   └─ Proto/Message.cs
 ├─ Server/                      # 멀티 프로토콜 서버 (REST/gRPC/TCP)
 │   ├─ Server.csproj
 │   ├─ Program.cs
 │   ├─ appsettings.json
 │   ├─ Data/
 │   │   ├─ Db.cs
 │   │   └─ RedisClient.cs
 │   ├─ Services/
 │   │   ├─ TcpServerService.cs
 │   │   ├─ Http/LogController.cs
 │   │   └─ Grpc/GreeterService.cs
 │   └─ Protos/greeter.proto
 └─ ClientTester/                # gRPC/TCP/REST 클라이언트 통합 테스트 콘솔
     ├─ ClientTester.csproj
     ├─ Program.cs
     ├─ appsettings.json
     └─ Clients/
         ├─ GrpcClient.cs
         ├─ TcpClient.cs
         └─ RestClient.cs
```

> **HTTP/3(QUIC)** 는 Kestrel에서 `UseHttps + Http1/2/3` 로 활성화하며, Windows 11/Server 2022에서는 MsQuic가 .NET 런타임에 포함되어 별도 설치 없이 동작합니다. (Linux의 경우 libmsquic 필요) [1](https://stackoverflow.com/questions/73736969/net-6-kestrel-http3-and-quic-linux-exception-this-platform-doesnt-support-quic)[3](https://accuweb.cloud/resource/articles/install-and-configure-dot-net-core-with-mssql-on-linux)[4](https://www.meziantou.net/using-http-3-quic-in-dotnet.htm)  
> **gRPC** 는 ASP.NET Core에서 **HTTPS(HTTP/2)** 를 요구/권장하며, REST와 병행 가능입니다. [5](https://github.com/arvndk/Nexus)

---

# 2) 공용 코덱 (길이‑프레임 / 무압축·무암호화)

**Common/Proto/Message.cs**  
TCP 메시지는 **[4바이트 총길이] + [고정 헤더 20바이트] + [Payload]** 로 구성합니다.

```csharp
// Common/Proto/Message.cs
using System.Buffers.Binary;

namespace Common.Proto
{
    public enum MsgType : ushort { Handshake=0, Data=1, Ack=2, Error=3 }

    public readonly struct MessageHeader
    {
        public readonly ushort Magic;      // 0x4D50 ("MP")
        public readonly byte   Version;    // 1
        public readonly byte   Flags;      // 0 (무압축/무암호화)
        public readonly ushort MsgType;
        public readonly ushort ErrorCode;  // 0=OK
        public readonly ulong  RequestId;  // 상관관계
        public readonly uint   PayloadLen;

        public MessageHeader(ushort magic, byte ver, byte flags, ushort msgType, ushort err,
                             ulong reqId, uint payloadLen)
        { Magic = magic; Version = ver; Flags = flags; MsgType = msgType; ErrorCode = err; RequestId = reqId; PayloadLen = payloadLen; }

        public static int Size => 20;

        public static MessageHeader Read(ReadOnlySpan<byte> span)
        {
            ushort magic      = BinaryPrimitives.ReadUInt16LittleEndian(span[0..2]);
            byte   ver        = span[2];
            byte   flags      = span[3];
            ushort msgType    = BinaryPrimitives.ReadUInt16LittleEndian(span[4..6]);
            ushort err        = BinaryPrimitives.ReadUInt16LittleEndian(span[6..8]);
            ulong  reqId      = BinaryPrimitives.ReadUInt64LittleEndian(span[8..16]);
            uint   payloadLen = BinaryPrimitives.ReadUInt32LittleEndian(span[16..20]);
            return new MessageHeader(magic, ver, flags, msgType, err, reqId, payloadLen);
        }

        public void Write(Span<byte> span)
        {
            BinaryPrimitives.WriteUInt16LittleEndian(span[0..2], Magic);
            span[2] = Version;
            span[3] = Flags;
            BinaryPrimitives.WriteUInt16LittleEndian(span[4..6], MsgType);
            BinaryPrimitives.WriteUInt16LittleEndian(span[6..8], ErrorCode);
            BinaryPrimitives.WriteUInt64LittleEndian(span[8..16], RequestId);
            BinaryPrimitives.WriteUInt32LittleEndian(span[16..20], PayloadLen);
        }
    }

    public static class MessageCodec
    {
        private const ushort Magic = 0x4D50;  // 'MP'
        private const byte   Version = 1;

        // Encode: payload -> [4B length] + [header] + [payload]
        public static byte[] Encode(ulong requestId, MsgType msgType, byte[] payload, ushort errorCode = 0)
        {
            var header = new MessageHeader(Magic, Version, 0, (ushort)msgType, errorCode, requestId, (uint)payload.Length);
            var hbuf = new byte[MessageHeader.Size]; header.Write(hbuf);

            int totalLen = hbuf.Length + payload.Length;
            var frame = new byte[4 + totalLen];
            BinaryPrimitives.WriteInt32LittleEndian(frame.AsSpan(0, 4), totalLen);
            Buffer.BlockCopy(hbuf, 0, frame, 4, hbuf.Length);
            Buffer.BlockCopy(payload, 0, frame, 4 + hbuf.Length, payload.Length);
            return frame;
        }

        // DecodeFrame(프레임 전체) — 클라이언트
        public static (MessageHeader header, byte[] payload) DecodeFrame(ReadOnlySpan<byte> full)
        {
            int totalLen = BinaryPrimitives.ReadInt32LittleEndian(full[..4]);
            var body = full.Slice(4, totalLen);
            return DecodeBody(body);
        }

        // DecodeBody([header+payload]) — 서버 핫패스
        public static (MessageHeader header, byte[] payload) DecodeBody(ReadOnlySpan<byte> headerPlusPayload)
        {
            var header = MessageHeader.Read(headerPlusPayload[..MessageHeader.Size]);
            var payload = headerPlusPayload.Slice(MessageHeader.Size, (int)header.PayloadLen).ToArray();
            return (header, payload);
        }
    }
}
```

> 길이‑프레임은 TCP 스트림에서 **메시지 경계**를 명확히 하기 위한 표준적 해결책으로 널리 권장됩니다. 단일 `Send`가 단일 `Receive`로 매핑되지 않는 TCP의 특성을 고려해야 합니다. [6](https://stackoverflow.com/questions/69197803/kestrel-bind-to-multiple-http-and-https-urls-through-appsettings-json)[7](https://thecodeblogger.com/2021/05/06/customizing-url-binding-for-asp-net-core-kestrel-server/)

---

# 3) 서버 (Server)

## 3.1 Server.csproj (.NET 10)

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Dapper" />
    <PackageReference Include="Microsoft.Data.SqlClient" />
    <PackageReference Include="StackExchange.Redis" />
    <PackageReference Include="Grpc.AspNetCore" />
    <PackageReference Include="Grpc.Tools" PrivateAssets="All" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Common\Common.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Protobuf Include="Protos\greeter.proto" GrpcServices="Server" />
  </ItemGroup>
</Project>
```

## 3.2 Kestrel 엔드포인트 + DI 등록 (Program.cs)

```csharp
using System.Net;
using Microsoft.AspNetCore.Server.Kestrel.Core;
using Microsoft.Data.SqlClient;
using StackExchange.Redis;
using Data;
using Services;
using Services.Grpc;

var builder = WebApplication.CreateBuilder(args);

// 80: HTTP/1.1 | 443: HTTPS(HTTP/1.1 + HTTP/2 + HTTP/3)
builder.WebHost.ConfigureKestrel(options =>
{
    options.Listen(IPAddress.Any, 80, o => o.Protocols = HttpProtocols.Http1);
    options.Listen(IPAddress.Any, 443, o =>
    {
        o.UseHttps("certs/server.pfx", "pfx_password");
        o.Protocols = HttpProtocols.Http1AndHttp2AndHttp3;
    });
});

// REST + gRPC
builder.Services.AddControllers();
builder.Services.AddGrpc();

// 로컬 MSSQL
builder.Services.AddSingleton<Func<SqlConnection>>(_ =>
    () => new SqlConnection(builder.Configuration.GetConnectionString("Mssql")));

// Dapper Repo / Redis
builder.Services.AddSingleton<Db>();
builder.Services.AddSingleton<IConnectionMultiplexer>(sp =>
    ConnectionMultiplexer.Connect(builder.Configuration.GetConnectionString("Redis")));
builder.Services.AddSingleton<Data.RedisClient>();

// TCP 서버(IHostedService)
builder.Services.AddHostedService<TcpServerService>();

var app = builder.Build();

app.MapControllers();
app.MapGrpcService<GreeterService>();

app.Run();
```

> **HTTP/3** 는 `UseHttps` 와 `Http1AndHttp2AndHttp3` 설정으로 활성화됩니다. 플랫폼 요건이 충족되지 않으면 자동으로 **HTTP/2/1.1** 로 폴백합니다. [1](https://stackoverflow.com/questions/73736969/net-6-kestrel-http3-and-quic-linux-exception-this-platform-doesnt-support-quic)[3](https://accuweb.cloud/resource/articles/install-and-configure-dot-net-core-with-mssql-on-linux)

## 3.3 appsettings.json

```json
{
  "ConnectionStrings": {
    "Mssql": "Server=(localdb)\\MSSQLLocalDB;Database=AppLogDb;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True;",
    "Redis": "localhost:6379,abortConnect=false"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
```

> 로컬 SQL 연결 문자열과 포트/인스턴스 표기는 공식 레퍼런스를 따릅니다. 개발 환경에서 자체 인증서 사용 시 `TrustServerCertificate=True` 로 완화할 수 있습니다(운영에선 신뢰된 인증서 권장). 

## 3.4 초기 스키마 (로그 테이블)

```sql
-- AppLogDb & dbo.Logs
IF DB_ID('AppLogDb') IS NULL CREATE DATABASE AppLogDb;
GO
USE AppLogDb;
GO
IF OBJECT_ID('dbo.Logs') IS NULL
BEGIN
  CREATE TABLE dbo.Logs
  (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    Level VARCHAR(16)      NOT NULL,
    Source NVARCHAR(128)   NULL,
    Message NVARCHAR(1024) NOT NULL,
    JsonData NVARCHAR(MAX) NULL,
    RequestId UNIQUEIDENTIFIER NULL,
    ErrorCode INT          NULL,
    ClientIp VARCHAR(64)   NULL,
    Tags NVARCHAR(256)     NULL,
    CreatedUtc DATETIME2(7) NOT NULL DEFAULT SYSUTCDATETIME()
  );
  CREATE INDEX IX_Logs_Level_CreatedUtc ON dbo.Logs(Level, CreatedUtc DESC);
  CREATE INDEX IX_Logs_RequestId       ON dbo.Logs(RequestId);
END
GO
```

## 3.5 Dapper Repo / Redis 래퍼

```csharp
// Data/Db.cs
using Dapper;
using Microsoft.Data.SqlClient;

namespace Data
{
    public class Db
    {
        private readonly Func<SqlConnection> _factory;
        public Db(Func<SqlConnection> factory) => _factory = factory;

        public async Task<long> InsertLogAsync(string level, string message,
            string? source=null, string? jsonData=null, Guid? requestId=null,
            int? errorCode=null, string? clientIp=null, string? tags=null, CancellationToken ct=default)
        {
            const string sql = @"
INSERT INTO dbo.Logs(Level, Source, Message, JsonData, RequestId, ErrorCode, ClientIp, Tags)
VALUES (@Level, @Source, @Message, @JsonData, @RequestId, @ErrorCode, @ClientIp, @Tags);
SELECT CAST(SCOPE_IDENTITY() AS BIGINT);";
            using var conn = _factory(); await conn.OpenAsync(ct);
            return await conn.ExecuteScalarAsync<long>(sql, new { level, source, message, jsonData, requestId, errorCode, clientIp, tags });
        }

        public async Task<IEnumerable<dynamic>> QueryRecentAsync(int top=50, CancellationToken ct=default)
        {
            using var conn = _factory(); await conn.OpenAsync(ct);
            return await conn.QueryAsync($"SELECT TOP {top} * FROM dbo.Logs ORDER BY CreatedUtc DESC");
        }
    }
}

// Data/RedisClient.cs
using StackExchange.Redis;

namespace Data
{
    public class RedisClient
    {
        private readonly IConnectionMultiplexer _mux;
        public RedisClient(IConnectionMultiplexer mux) => _mux = mux;
        public Task<string?> GetAsync(string key) => _mux.GetDatabase().StringGetAsync(key).AsTask();
        public Task SetAsync(string key, string value, TimeSpan? expiry=null) => _mux.GetDatabase().StringSetAsync(key, value, expiry).AsTask();
    }
}
```

## 3.6 REST 컨트롤러

```csharp
// Services/Http/LogController.cs
using Microsoft.AspNetCore.Mvc;
using Data;

[ApiController]
[Route("api/logs")]
public class LogController : ControllerBase
{
    private readonly Db _db;
    private readonly Data.RedisClient _redis;
    public LogController(Db db, Data.RedisClient redis) { _db = db; _redis = redis; }

    [HttpGet]
    public async Task<IActionResult> Get(CancellationToken ct)
    {
        var cached = await _redis.GetAsync("logs:recent");
        if (cached is not null) return Content(cached, "application/json");
        var rows = await _db.QueryRecentAsync(ct: ct);
        var json = System.Text.Json.JsonSerializer.Serialize(rows);
        await _redis.SetAsync("logs:recent", json, TimeSpan.FromSeconds(30));
        return Content(json, "application/json");
    }

    [HttpPost]
    public async Task<IActionResult> Post([FromBody] LogDto dto, CancellationToken ct)
    {
        var id = await _db.InsertLogAsync(dto.Level, dto.Message, dto.Source, dto.JsonData, dto.RequestId, dto.ErrorCode, HttpContext.Connection.RemoteIpAddress?.ToString(), dto.Tags, ct);
        return Ok(new { id });
    }
}
public record LogDto(string Level, string Message, string? Source, string? JsonData, Guid? RequestId, int? ErrorCode, string? Tags);
```

## 3.7 gRPC 프로토 & 서비스

**Protos/greeter.proto**

```proto
syntax = "proto3";
option csharp_namespace = "Services.Grpc";

package greeter;
service Greeter { rpc SayHello (HelloRequest) returns (HelloReply); }
message HelloRequest { string name = 1; }
message HelloReply   { string message = 1; }
```

**Services/Grpc/GreeterService.cs**

```csharp
using Grpc.Core;

namespace Services.Grpc
{
    public class GreeterService : Greeter.GreeterBase
    {
        public override Task<HelloReply> SayHello(HelloRequest request, ServerCallContext context)
            => Task.FromResult(new HelloReply { Message = $"Hello, {request.Name}" });
    }
}
```

> gRPC는 **HTTP/2 + TLS(HTTPS)** 를 기본으로 합니다. Kestrel에서 REST와 병행 가능합니다. [5](https://github.com/arvndk/Nexus)

## 3.8 고성능 TCP 서버 (SocketAsyncEventArgs)

```csharp
// Services/TcpServerService.cs
using System.Net;
using System.Net.Sockets;
using System.Text;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using Common.Proto;

namespace Services
{
    internal class BufferManager
    {
        private readonly byte[] _buffer;
        private readonly int _chunk;
        private readonly Stack<int> _free = new();
        private int _next;
        public BufferManager(int totalBytes, int chunk) { _buffer = new byte[totalBytes]; _chunk = chunk; }
        public bool SetBuffer(SocketAsyncEventArgs e)
        {
            if (_free.Count > 0) { var off = _free.Pop(); e.SetBuffer(_buffer, off, _chunk); return true; }
            if (_next + _chunk > _buffer.Length) return false;
            e.SetBuffer(_buffer, _next, _chunk); _next += _chunk; return true;
        }
        public void FreeBuffer(SocketAsyncEventArgs e) { _free.Push(e.Offset); e.SetBuffer(null!, 0, 0); }
    }

    public class TcpServerService : IHostedService
    {
        private readonly ILogger<TcpServerService> _log;
        private Socket? _listen;
        private readonly ConcurrentStack<SocketAsyncEventArgs> _pool = new();
        private BufferManager? _bm;
        private readonly SemaphoreSlim _limit;
        private const int BufferSize = 4096;
        private const int MaxConnections = 2000;
        private readonly int _port = 9000;

        public TcpServerService(ILogger<TcpServerService> log) { _log = log; _limit = new SemaphoreSlim(MaxConnections, MaxConnections); }

        public Task StartAsync(CancellationToken ct)
        {
            _bm = new BufferManager(BufferSize * MaxConnections, BufferSize);
            for (int i=0; i<MaxConnections; i++)
            {
                var saea = new SocketAsyncEventArgs();
                if (!_bm.SetBuffer(saea)) throw new OutOfMemoryException();
                saea.Completed += IO_Completed;
                _pool.Push(saea);
            }

            _listen = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            _listen.Bind(new IPEndPoint(IPAddress.Any, _port));
            _listen.Listen(1024);
            _log.LogInformation("TCP listening {Port}", _port);

            StartAccept();
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken ct) { try { _listen?.Close(); } catch { } _listen = null; return Task.CompletedTask; }

        private void StartAccept()
        {
            var acc = new SocketAsyncEventArgs(); acc.Completed += Accept_Completed;
            if (!(_listen?.AcceptAsync(acc) ?? true)) ProcessAccept(acc);
        }
        private void Accept_Completed(object? s, SocketAsyncEventArgs e) => ProcessAccept(e);

        private void ProcessAccept(SocketAsyncEventArgs e)
        {
            var client = e.AcceptSocket; e.AcceptSocket = null;
            if (_listen != null) StartAccept();
            if (client == null) return;

            if (!_limit.Wait(0)) { SafeClose(client); return; }
            if (!_pool.TryPop(out var io)) { SafeClose(client); _limit.Release(); return; }

            io.UserToken = new Conn(client);
            if (!client.ReceiveAsync(io)) ProcessReceive(io);
        }

        private void IO_Completed(object? s, SocketAsyncEventArgs e)
        {
            if (e.LastOperation == SocketAsyncOperation.Receive) ProcessReceive(e);
            else if (e.LastOperation == SocketAsyncOperation.Send) ProcessSend(e);
        }

        private class Conn
        {
            public Socket Socket { get; }
            public int Expected = -1;
            public MemoryStream Acc = new();
            public Conn(Socket s) => Socket = s;
        }

        private void ProcessReceive(SocketAsyncEventArgs e)
        {
            var st = (Conn?)e.UserToken; var cli = st?.Socket;
            if (st is null || cli is null || e.SocketError != SocketError.Success || e.BytesTransferred == 0) { Close(e); return; }

            var span = new ReadOnlySpan<byte>(e.Buffer!, e.Offset, e.BytesTransferred);
            var pos = 0;

            while (pos < span.Length)
            {
                if (st.Expected < 0)
                {
                    if (span.Length - pos < 4) { st.Acc.Write(span[pos..].ToArray()); pos = span.Length; break; }
                    st.Expected = BitConverter.ToInt32(span.Slice(pos, 4)); pos += 4; st.Acc.SetLength(0);
                }
                var remain = st.Expected - (int)st.Acc.Length;
                var take = Math.Min(remain, span.Length - pos);
                st.Acc.Write(span.Slice(pos, take).ToArray()); pos += take;

                if (st.Acc.Length == st.Expected)
                {
                    // [header+payload] 완성
                    var headerPlusPayload = st.Acc.ToArray();
                    st.Expected = -1;

                    var respFrame = HandleMessage(headerPlusPayload);
                    e.SetBuffer(respFrame, 0, respFrame.Length);
                    if (!cli.SendAsync(e)) ProcessSend(e);
                    return;
                }
            }
            if (!cli.ReceiveAsync(e)) ProcessReceive(e);
        }

        private byte[] HandleMessage(byte[] headerPlusPayload)
        {
            try
            {
                var (hdr, plain) = MessageCodec.DecodeBody(headerPlusPayload);
                var text = Encoding.UTF8.GetString(plain);
                var result = Encoding.UTF8.GetBytes($"Echo: {text}".ToUpperInvariant());
                return MessageCodec.Encode(hdr.RequestId, MsgType.Ack, result, errorCode: 0);
            }
            catch (Exception)
            {
                var err = Encoding.UTF8.GetBytes("DECODE_ERROR");
                return MessageCodec.Encode(0, MsgType.Error, err, errorCode: 1);
            }
        }

        private void ProcessSend(SocketAsyncEventArgs e)
        {
            var st = (Conn?)e.UserToken; var cli = st?.Socket;
            if (cli is null) { Close(e); return; }
            _bm!.SetBuffer(e);
            if (!cli.ReceiveAsync(e)) ProcessReceive(e);
        }

        private void Close(SocketAsyncEventArgs e)
        {
            var st = (Conn?)e.UserToken; var cli = st?.Socket;
            if (cli != null) SafeClose(cli);
            st?.Acc.Dispose(); e.UserToken = null;
            try { _bm?.FreeBuffer(e); _bm?.SetBuffer(e); } catch { }
            _pool.Push(e); _limit.Release();
        }

        private static void SafeClose(Socket s) { try { s.Shutdown(SocketShutdown.Both); } catch { } try { s.Close(); } catch { } }
    }
}
```

> .NET의 TCP 고급 시나리오에서는 `Socket`/`SocketAsyncEventArgs` 를 통해 고성능 IOCP 기반 처리가 가능합니다. 간단한 경우엔 `TcpClient/TcpListener` 를 사용할 수 있으나, 저수준 제어·성능 최적화는 `Socket` 사용을 권장합니다. [8](https://www.tutorialpedia.org/blog/can-i-set-listen-urls-in-appsettings-json-in-asp-net-core-2-0-preview/)[9](https://riptutorial.com/dot-net-core-2/learn/100014/brotli-compression)

---

# 4) 클라이언트 통합 테스트 (ClientTester)

## 4.1 ClientTester.csproj (.NET 10)

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Grpc.Net.Client" />
    <PackageReference Include="Google.Protobuf" />
    <PackageReference Include="Grpc.Tools" PrivateAssets="All" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Common\Common.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Protobuf Include="..\Server\Protos\greeter.proto" GrpcServices="Client" />
  </ItemGroup>
</Project>
```

## 4.2 appsettings.json

```json
{
  "Endpoints": {
    "GrpcBaseAddress": "https://localhost:443",
    "RestBaseAddress": "https://localhost:443",
    "TcpHost": "127.0.0.1",
    "TcpPort": 9000
  }
}
```

## 4.3 Program.cs — 선택 실행

```csharp
using Microsoft.Extensions.Configuration;
using ClientTester.Clients;

class Program
{
    static async Task<int> Main(string[] args)
    {
        var config = new ConfigurationBuilder()
            .AddJsonFile("appsettings.json", optional: true)
            .AddEnvironmentVariables()
            .AddCommandLine(args)
            .Build();

        var grpcBase = config["Endpoints:GrpcBaseAddress"] ?? "https://localhost:443";
        var restBase = config["Endpoints:RestBaseAddress"] ?? "https://localhost:443";
        var tcpHost  = config["Endpoints:TcpHost"] ?? "127.0.0.1";
        var tcpPort  = int.TryParse(config["Endpoints:TcpPort"], out var p) ? p : 9000;

        var selection = args.FirstOrDefault()?.ToLowerInvariant();
        if (string.IsNullOrWhiteSpace(selection))
        {
            Console.WriteLine("Select client to run: 1) gRPC  2) TCP  3) REST");
            selection = Console.ReadLine()?.Trim().ToLowerInvariant();
        }

        try
        {
            switch (selection)
            {
                case "1": case "grpc": await GrpcClient.RunAsync(grpcBase); break;
                case "2": case "tcp":  await TcpClientRunner.RunAsync(tcpHost, tcpPort); break;
                case "3": case "rest": await RestClient.RunAsync(restBase); break;
                default:
                    Console.WriteLine("Usage: ClientTester [grpc|tcp|rest]");
                    return 1;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] {ex.Message}");
            return 2;
        }
        return 0;
    }
}
```

## 4.4 gRPC / TCP / REST 클라이언트

```csharp
// Clients/GrpcClient.cs
using Grpc.Net.Client;
using Services.Grpc;

namespace ClientTester.Clients
{
    public static class GrpcClient
    {
        public static async Task RunAsync(string baseAddress)
        {
            Console.WriteLine($"[gRPC] {baseAddress}");
            using var channel = GrpcChannel.ForAddress(baseAddress);
            var client = new Greeter.GreeterClient(channel);
            var reply = await client.SayHelloAsync(new HelloRequest { Name = "ClientTester" });
            Console.WriteLine($"[gRPC] {reply.Message}");
        }
    }
}
```

```csharp
// Clients/TcpClient.cs
using System.Net.Sockets;
using System.Text;
using Common.Proto;

namespace ClientTester.Clients
{
    public static class TcpClientRunner
    {
        public static async Task RunAsync(string host, int port)
        {
            Console.WriteLine($"[TCP] {host}:{port}");
            using var client = new TcpClient(); await client.ConnectAsync(host, port);
            using var stream = client.GetStream();

            Console.WriteLine("Type lines to send. Ctrl+C to exit.");
            while (true)
            {
                var line = Console.ReadLine(); if (line is null) break;
                var frame = MessageCodec.Encode((ulong)Random.Shared.NextInt64(), MsgType.Data, Encoding.UTF8.GetBytes(line));
                await stream.WriteAsync(frame);

                var lenBuf = new byte[4]; await ReadExactlyAsync(stream, lenBuf, 0, 4);
                int totalLen = BitConverter.ToInt32(lenBuf, 0);
                var bodyBuf = new byte[totalLen]; await ReadExactlyAsync(stream, bodyBuf, 0, totalLen);

                var full = new byte[4 + totalLen]; BitConverter.GetBytes(totalLen).CopyTo(full, 0); Buffer.BlockCopy(bodyBuf, 0, full, 4, totalLen);
                var (hdr, plain) = MessageCodec.DecodeFrame(full);
                Console.WriteLine($"[TCP {hdr.MsgType}] {Encoding.UTF8.GetString(plain)}");
            }
        }
        private static async Task ReadExactlyAsync(NetworkStream s, byte[] buf, int offset, int count)
        {
            int total = 0;
            while (total < count)
            {
                var read = await s.ReadAsync(buf.AsMemory(offset + total, count - total));
                if (read == 0) throw new IOException("Remote closed"); total += read;
            }
        }
    }
}
```

```csharp
// Clients/RestClient.cs
using System.Net.Http.Json;

namespace ClientTester.Clients
{
    public static class RestClient
    {
        public static async Task RunAsync(string baseAddress)
        {
            Console.WriteLine($"[REST] {baseAddress}");
            using var http = new HttpClient { BaseAddress = new Uri(baseAddress) };

            var recent = await http.GetStringAsync("/api/logs");
            Console.WriteLine($"[GET /api/logs] {recent}");

            var dto = new { Level="INFO", Message="ClientTester REST test", Source="ClientTester", JsonData="{\"hello\":\"world\"}", Tags="rest-test" };
            var resp = await http.PostAsJsonAsync("/api/logs", dto);
            Console.WriteLine($"[POST /api/logs] {(int)resp.StatusCode} {resp.StatusCode}");
        }
    }
}
```

---

# 5) 실행 절차 (Windows 11, VS 2026, .NET 10)

1. **개발용 인증서**
   ```powershell
   dotnet dev-certs https --trust
   dotnet dev-certs https --export-path ./Server/certs/server.pfx --password pfx_password
   ```
   > 로컬 HTTPS 개발 인증서를 생성/신뢰/내보내기하는 공식 CLI입니다. [2](https://learn.microsoft.com/en-us/dotnet/standard/security/cross-platform-cryptography)

2. **DB 스키마 적용**  
   SQL Server(LocalDB/Express)에 3.4의 T‑SQL 실행.

3. **빌드 & 서버 실행**
   ```bash
   dotnet build
   dotnet run --project Server
   ```

4. **클라이언트 테스트**
   ```bash
   # 메뉴 선택
   dotnet run --project ClientTester
   # 즉시 실행
   dotnet run --project ClientTester -- grpc
   dotnet run --project ClientTester -- tcp
   dotnet run --project ClientTester -- rest
   ```

5. **방화벽/포트**  
   80/tcp, 443/tcp(+UDP 443 for HTTP/3), 9000/tcp 허용.  
   > HTTP/3는 QUIC(UDP) 이므로 **UDP 443** 도 열어야 합니다. [1](https://stackoverflow.com/questions/73736969/net-6-kestrel-http3-and-quic-linux-exception-this-platform-doesnt-support-quic)

---

# 6) 운영/보안/성능 체크리스트 (프로토타입 기준)

- **HTTP/3(QUIC)**: `UseHttps + Http1AndHttp2AndHttp3` 구성. 클라이언트/플랫폼 요건 미충족 시 자동 폴백. [1](https://stackoverflow.com/questions/73736969/net-6-kestrel-http3-and-quic-linux-exception-this-platform-doesnt-support-quic)  
- **gRPC**: HTTPS(HTTP/2) 필수/권장. REST와 병행 가능. [5](https://github.com/arvndk/Nexus)  
- **TCP**: 길이‑프레임으로 부분 수신 대응, **객체/버퍼 풀 재사용**으로 GC 압박 감소. [9](https://riptutorial.com/dot-net-core-2/learn/100014/brotli-compression)  
- **SqlClient**: 로컬 인스턴스/포트/신뢰 설정 확인(개발용 인증서 시 `TrustServerCertificate=True`).   
- **dev-certs**: 로컬 HTTPS 빠른 설정(Windows 11에서 자동 신뢰). [2](https://learn.microsoft.com/en-us/dotnet/standard/security/cross-platform-cryptography)

---

# 7) 다음 단계(원하시면 바로 확장)

- **TCP 핸드셰이크(`MsgType.Handshake`)**: 버전/기능 교섭(압축·암호화 플래그), 세션 파라미터 협상.  
- **암호화/압축 재도입**: 플래그/확장 헤더만 추가하면 **Brotli + AES‑GCM** 으로 손쉽게 확장 가능합니다. (AES‑GCM은 nonce 유일성/태그 검증/AAD로 헤더 인증) [10](https://www.freecodecamp.org/news/get-started-with-aspnet-core-and-grpc-handbook/)  
- **관측성**: Serilog/OpenTelemetry, HealthChecks 추가.  
- **자동 스모크 테스트**: `ClientTester` 에 `all` 모드 추가하여 gRPC/TCP/REST 연쇄 검증.

---

조기환 님, **VS 2026 + .NET 10 최종본**을 일괄 정리했습니다.  
지금 바로 실행해 보시고, 빌드/런타임에서 경고·에러가 보이면 메시지 그대로 알려주세요.  
필요하시면 **핸드셰이크/세션키(ECDH) 설계**, **배포 스크립트**, **단위테스트**까지 이어서 마무리해 드릴게요.